/**
 * Reflective thrift IDL description.
 *
 * Comments are gathered before the start of the next statement.
 *
 * - Line comments are accumulated with newline delimiter.
 *   Each line is individually trimmed.
 * - Block comments replace the entire comment.
 *   The first space after '*' on each line is ignored.
 */
namespace java net.morimekta.providence.model
namespace js morimekta.providence.model

/** Describes */
struct FilePos {
    /** The line no in the file. The first line is 1 */
    1: required i32 line_no;
    /** The character porisiotn in the line. The first char is 0. */
    2: required i32 line_pos;
} (java.public.constructor = "")

/**
 * Base declaration type. All declarations have these fields.
 */
interface Decl {
    /**
     * Documentation for the specific declaration.
     */
    optional string documentation;
    /**
     * Name of the type, constant or service.
     */
    required string name;
    /**
     * Start position in file of the declaration.
     */
    optional FilePos start_pos;
    /**
     * End position in file of the declaration.
     */
    optional FilePos end_pos;
}

/**
 * <name> (= <value>)
 */
struct EnumValue implements Decl {
    1: optional string documentation;
    2: required string name;
    3: optional i32    id;
    4: optional map<string,string> annotations (container = "SORTED");
    /** The start of the definition (position of 'name')*/
    10: optional FilePos start_pos;
    /** The end of the definition (position of ';' or last pos of value) */
    11: optional FilePos end_pos;
}

/**
 * enum {
 *   (<value> ([;,])?)*
 * }
 */
struct EnumType implements Decl {
    1: optional string documentation;
    2: required string name;
    3:          list<EnumValue> values;
    4: optional map<string,string> annotations (container = "SORTED");
    /** The start of the definition (position of 'enum')*/
    10: optional FilePos start_pos;
    /** The end of the definition (position of '}') */
    11: optional FilePos end_pos;
}

/**
 * typedef <type> <name>
 */
struct TypedefType implements Decl {
    1: optional string documentation;
    2: required string type;
    3: required string name;
    /** The start of the definition (position of 'typedef')*/
    10: optional FilePos start_pos;
    /** The end of the definition */
    11: optional FilePos end_pos;
}

/**
 * Struct variant for StructType. The lower-case of the enum value is the
 * thrift keyword.
 *
 * STRUCT:    Normal Structure.
 * UNION:     Only one field set to be valid.
 * EXCEPTION: Handled as exception (Java, Python etc.).
 *
 * Providence Only:
 *
 * INTERFACE: Not a real type. Only interface. Struct can 'implement' this
 *            And will then require to have matching fields. Field ids not
 *            allowed.
 */
enum MessageVariant {
    STRUCT = 1,
    UNION = 2,
    EXCEPTION = 3,
    INTERFACE = 4,
}

/**
 * The requirement of the field.
 */
enum FieldRequirement {
    /**
     * Will be serialized, will be made present from builder,
     * but not required for validity.
     */
    DEFAULT  = 0,
    /** Presence is optional. */
    OPTIONAL = 1,
    /** Must be set for message to be 'valid'. */
    REQUIRED = 2,
}

/**
 * For fields:
 *   (<key>:)? (required|optional)? <type> <name> (= <default_value>)?
 * For const:
 *   const <type> <name> = <default_value>
 *
 * Fields without key is assigned values ranging from 65335 and down (2^16-1)
 * in order of appearance. Because of the "in order of appearance" the field
 * *must* be filled by the IDL parser.
 *
 * Consts are always given the key '0'.
 */
struct FieldType implements Decl {
    1: optional string documentation;
    2: required i32    id;
    3: optional FieldRequirement requirement = FieldRequirement.DEFAULT;
    4: required string type;
    5: required string name;
    6: optional string default_value;
    7: optional map<string,string> annotations = {} (container = "SORTED");

    /**
     * Note the start of the default value in the parsed thrift file, this can be used
     * for making more accurate exception / parse data from the const parser.
     */
    9: required FilePos value_start_pos;
    /** The start of the definition (position of field ID)*/
    10: optional FilePos start_pos;
    /** The end of the definition */
    11: optional FilePos end_pos;
}

/**
 * <variant> {
 *   (<field> ([,;])?)*
 * }
 */
struct MessageType implements Decl {
    1: optional string documentation;
    2: optional MessageVariant variant = MessageVariant.STRUCT;
    3: required string name;
    4:          list<FieldType> fields;
    5: optional map<string,string> annotations = {} (container = "SORTED");
    /** Interface this message is implementing. */
    6: optional string implementing;
    /** The start of the definition (position of 'struct' / message type)*/
    10: optional FilePos start_pos;
    /** The end of the definition (position of '}') */
    11: optional FilePos end_pos;
}

/**
 * (oneway)? <return_type> <name>'('<param>*')' (throws '(' <exception>+ ')')?
 */
struct FunctionType implements Decl {
    1: optional string documentation;
    2: optional bool one_way = false;
    3: optional string return_type
    4: required string name;
    5:          list<FieldType> params = [];
    6: optional list<FieldType> exceptions = [];
    7: optional map<string,string> annotations = {} (container = "SORTED");
    /** The start of the definition (position of return type)*/
    10: optional FilePos start_pos;
    /** The end of the definition */
    11: optional FilePos end_pos;
}

/**
 * service (extends <extend>)? {
 *   (<method> [;,]?)*
 * }
 */
struct ServiceType implements Decl {
    1: optional string documentation;
    2: required string name;
    3: optional string extend;
    4:          list<FunctionType> methods = [];
    5: optional map<string,string> annotations = {} (container = "SORTED");
    /** The start of the definition (position of 'service')*/
    10: optional FilePos start_pos;
    /** The end of the definition (position of '}') */
    11: optional FilePos end_pos;
}

/**
 * const <type> <name> = <value>
 */
struct ConstType implements Decl {
    1: optional string documentation;
    4: required string type;
    5: required string name;
    6: required string value;
    7: optional map<string,string> annotations = {} (container = "SORTED");

    /**
     * Note the start of the const in the parsed thrift file, this can be used
     * for making more accurate exception / parse data from the const parser.
     */
    9: required FilePos value_start_pos;
    /** The start of the definition (position of 'enum')*/
    10: optional FilePos start_pos;
    /** The end of the definition (position of '}') */
    11: optional FilePos end_pos;
}

/**
 * ( <enum> | <typedef> | <struct> | <service> | <const> )
 */
union Declaration of Decl {
    1: EnumType    decl_enum;
    2: TypedefType decl_typedef;
    3: MessageType decl_message;
    4: ServiceType decl_service;
    5: ConstType   decl_const;
}

/**
 * <namespace>* <include>* <declataion>*
 */
struct ProgramType {
    /**
     * Program documentation must come before the first statement of the header.
     */
    1: optional string documentation;

    /**
     * The program name, deducted from the .thrift IDL file name.
     */
    2: required string program_name;

    /**
     * List of included thrift files. Same as from the actual thrift file.
     *
     * include "<program>.thrift"
     */
    3: optional list<string> includes = [];

    /**
     * Map of language to laguage dependent namespace identifier.
     *
     * namespace <key> <value>
     */
    4: optional map<string,string> namespaces = {} (container = "SORTED");

    /**
     * List of declarations in the program file. Same order as in the thrift file.
     */
    5: optional list<Declaration> decl = [];
}

/**
 * A meta object describing a parsed program file. This may include the
 * included programs as their own meta file. The lines of the original
 * program .thrift file is also included.
 */
struct ProgramMeta {
    /** Full absolute path to the file. */
    1: optional string file_path;
    /** The lines of the program file */
    2: optional list<string> file_lines;
    /** The program type definition */
    3: optional ProgramType program;
    /** Map of program name to meta of included programs */
    4: optional map<string, ProgramMeta> includes;
}

/**
 * Set of words used in thrift IDL as specific meanings.
 */
const set<string> kThriftKeywords = [
  // File header.
  "include", "namespace",
  // Primitive types.
  "bool", "byte", "i8", "i16", "i32", "i64", "double", "string", "binary",
  // Containers
  "list", "set", "map",
  // Defined Types keywords.
  "enum", "struct", "union", "exception", "const", "typedef", "service",
  // Field modifiers
  "required", "optional",
  // Extra keywords related to services.
  "extends", "throws", "oneway", "void",
];

/**
 * Set of keywords only used in .providence files.
 */
const set<string> kProvidenceKeywords = [
  // Defined Types keywords.
  "interface",
  // Extra keywords related to messages.
  "implements", "of",
];

/**
 * Other words that are reserved for language compat reasons. E.g. to enable
 * C++ classes to follow getter method naming convention to be raw field name
 * (java naming convention is typename safe):
 *
 * Apache Thrift has a pretty extensive list of reserved words. In order to be
 * compatible with Apache Thrift, all of these must be blocked from:
 *
 * - enum names
 * - enum value names
 * - message names
 * - message field names
 * - service names
 * - service method names
 *
 * This compatibility check can be turned off in the compiler and generator
 * if wanted, but should generally be kept on. Note that the name check here is
 * always case sensitive.
 */
const set<string> kReservedWords = [
    "abstract"
    "alias"
    "and"
    "args"
    "as"
    "assert"
    "begin"
    "break"
    "case"
    "catch"
    "class"
    "clone"
    "continue"
    "declare"
    "def"
    "default"
    "del"
    "delete"
    "do"
    "dynamic"
    "elif"
    "else"
    "elseif"
    "elsif"
    "end"
    "enddeclare"
    "endfor"
    "endforeach"
    "endif"
    "endswitch"
    "endwhile"
    "ensure"
    "except"
    "exec"
    "finally"
    "float"
    "for"
    "foreach"
    "from"
    "function"
    "global"
    "goto"
    "if"
    "implements"
    "import"
    "in"
    "inline"
    "instanceof"
    "interface"
    "is"
    "int"
    "lambda"
    "long"
    "module"
    "native"
    "new"
    "next"
    "nil"
    "not"
    "or"
    "package"
    "pass"
    "public"
    "print"
    "private"
    "protected"
    "raise"
    "redo"
    "rescue"
    "retry"
    "register"
    "return"
    "self"
    "short"
    "sizeof"
    "static"
    "super"
    "switch"
    "synchronized"
    "then"
    "this"
    "throw"
    "transient"
    "try"
    "undef"
    "unless"
    "unsigned"
    "until"
    "use"
    "var"
    "virtual"
    "volatile"
    "when"
    "while"
    "with"
    "xor"
    "yield"
];
